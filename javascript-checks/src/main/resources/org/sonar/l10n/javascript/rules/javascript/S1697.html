<p>当<code>null</code> 或 <code>undefined</code>测试中的相等运算符，或后面的逻辑运算符被反转时，代码在解引用对象之前看起来是安全的空测试对象。不幸的是，效果正好相反——对象是
只有当 <code>null</code>/<code>undefined</code>时，才进行空测试，然后解引用，从而保证<code>TypeError</code>.</p>
<h2>不合规的代码示例</h2>
<pre>
if (str == null &amp;&amp; str.length == 0) {
  console.log("String is empty");
}

if (str == undefined &amp;&amp; str.length == 0) {
  console.log("String is empty");
}

if (str != null || str.length &gt; 0) {
  console.log("String is not empty");
}

if (str != undefined || str.length &gt; 0) {
  console.log("String is not empty");
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if (str != null &amp;&amp; str.length == 0) {
  console.log("String is empty");
}

if (str != undefined &amp;&amp; str.length == 0) {
  console.log("String is empty");
}

if (str == null || str.length &gt; 0) {
  console.log("String is not empty");
}

if (str == undefined || str.length &gt; 0) {
  console.log("String is not empty");
}
</pre>
<h2>弃用</h2>
<p>这条规则是不合宜的; 使用 {rule:javascript:S2259} 。</p>

